# -*- coding: utf-8 -*-
"""A4_Pilot_Version_BW.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q-L-BDJSQO2C4b9GqHrcCnbOaMA_4BcO

### Import Libraries
"""

import numpy as np
import matplotlib.pyplot as plt
import sklearn as sk
import seaborn as sns
import tensorflow as tf

from scipy.io import loadmat

from skimage import color
from skimage import io
from sklearn.model_selection import train_test_split

from keras.datasets import mnist
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten

#Importing the CNN related layers 
from keras.layers.convolutional import Conv2D, MaxPooling2D
from keras.utils import np_utils
from keras.regularizers import l1
from keras.regularizers import l2



# %matplotlib inline
plt.rcParams['figure.figsize'] = (16.0, 4.0)

""" fixing the random seed for reproducibility"""
seed = 0
np.random.seed(seed)

"""### Import the data from google drive"""


def load_data(path):
    """ Helper function for loading a MAT-File"""
    data = loadmat(path)
    return data['X'], data['y']
X_train, y_train = load_data("train_32x32.mat")
X_test, y_test = load_data("test_32x32.mat")

print("Training Set", X_train.shape, y_train.shape)
print("Test Set", X_test.shape, y_test.shape)

"""**Transposing the the train and test data
by converting it from  
(width, height, channels, size) -> (size, width, height, channels)**
"""

# Transpose the image arrays if channel is not last
if (X_train.shape[3] != 3):
  X_train, y_train = X_train.transpose((3,0,1,2)), y_train[:,0]
  X_test, y_test = X_test.transpose((3,0,1,2)), y_test[:,0]

print("Training Set", X_train.shape)
print("Test Set", X_test.shape)

# Calculate the total number of images
num_images = X_train.shape[0] + X_test.shape[0]

print("Total Number of Images", num_images)

# a helper function to display images . Note that color and gray picture need different codes:

def plot_images(img, labels, nrows, ncols):
    """ Plot nrows x ncols images
    """
    fig, axes = plt.subplots(nrows, ncols)
    for i, ax in enumerate(axes.flat): 
        if img[i].shape == (32, 32, 3):
          # for color
            ax.imshow(img[i]) 
        else:
          #for grayscale
            ax.imshow(img[i,:,:,0])
        ax.set_xticks([]); ax.set_yticks([])
        ax.set_title(labels[i])

"""If you want to see some of the images:"""

print("y_train is",y_train)
plot_images(X_train, y_train,2,10)

# Make grayscale
# if channel is 3, then it is RGB. convert it to grayscale
if X_train.shape[3] == 3:
  X_train= np.dot(X_train,[0.30,0.59,.11])
  X_train = np.expand_dims(X_train,axis=3).astype('float32')
  X_train.shape
  
if X_test.shape[3] == 3:
  X_test= np.dot(X_test,[0.30,0.59,.11])
  X_test = np.expand_dims(X_test,axis=3).astype('float32')
  X_test.shape

"""### print some of the test data"""

plot_images(X_test, y_test, 1, 10)

"""### Normalize the data"""

# scale the data:

X_train_norm = X_train/255
X_test_norm = X_test/255

"""
Use Keras to make the label categorical
"""
y_train[y_train==10] = 0
y_test[y_test==10] = 0
y_train_cat = np_utils.to_categorical(y_train)
y_test_cat = np_utils.to_categorical(y_test)
num_classes = y_train_cat.shape[1]
print("the number of categorical classess is:",num_classes)

"""### Getting the number, height and width of the images:"""

training_samples, height, width, channel = X_train_norm.shape
testing_samples,_,_,_  = X_test_norm.shape

"""### The model:"""

model = Sequential()
model.add(Conv2D(48, (3, 3), input_shape=(height,width ,channel), activation='relu'))


model.add(Conv2D(64, (3,3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Conv2D(128, (5, 5), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Dropout(0.20))
model.add(Flatten())
model.add(Dense(128, activation='relu', activity_regularizer=l2(0.0025)))
model.add(Dense(num_classes, activation='softmax'))
# Compile model
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

"""**Fit the model**"""

model.fit(X_train_norm, y_train_cat, validation_data=(X_test_norm, y_test_cat),epochs=10, batch_size=100)





model.summary()

# calculate the scores and loss function
score = model.evaluate(X_test_norm, y_test_cat, verbose=0)
print('Test loss:', score[0])
print('Test accuracy:', score[1])

# Save entire model to a HDF5 file
#model.save('my_model92_30.h5')

